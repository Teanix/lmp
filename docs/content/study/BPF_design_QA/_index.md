---
title: BPF设计问答
description: "这个简短的问答试图解决对BPF的一些误解，并对BPF的发展给出方向。"
weight: 1
---

1. BPF是一个类似x64和arm64的通用指令集吗？

> 答：不是。

2. BPF是一个通用的虚拟机吗？

> 答：不是。BPF是具有C调用惯例的通用指令集。

3. 为什么选择C语言的调用惯例？

> 答：因为BPF程序被设计在Linux内核中运行，而Linux内核是用C语言编写的，因此BPF定义了与两种最常用的架构x64和arm64兼容的指令集（并考虑到其他架构的特殊情况），并且定义了与这些架构上Linux内核的C语言调用惯例兼容的调用惯例。

4. 将来是否可以支持多个返回值？

> 答：不能。BPF只允许寄存器R0被用作返回值。

5. 将来能不能支持5个以上的函数参数？

> 答：不能。BPF调用惯例只允许寄存器R1-R5被用作参数。BPF不是一个独立的指令集(不像x64 ISA允许msft、cdecl和其他约定）。

6. BPF程序能否访问指令指针或返回地址？

> 答：不能。

7. BPF程序可以访问堆栈指针吗？

> 答：不能。只有帧指针（寄存器R10）可以访问。从编译器的角度来看，必须有堆栈指针。例如，LLVM在其BPF后端将寄存器R11定义为堆栈指针，但它确保生成的代码从不使用它。

8. C语言调用惯例是否减少了可能的用例？

> 答：是的。BPF设计迫使以内核辅助函数和内核对象（如BPF映射）的形式增加主要功能，并在它们之间实现无缝互操作。它让内核调用BPF程序和程序调用内核助手的开销为零，因为它们都是本地C代码。这对于JIT化的BPF程序来说尤其如此，它们与本地内核C代码没有区别。

9. 这是否意味着不允许对BPF代码进行 "创新 "扩展？

> 答：软件上是的。至少目前是这样，直到BPF核心支持bpf-to-bpf调用、间接调用、循环、全局变量、跳转表、只读部分以及C代码能产生的所有其他正常结构。

10. 能否以一种安全的方式支持循环？

> 答：目前还不清楚。BPF开发者正在努力寻找一种支持有界循环的方法。

11. 验证器的限制是什么？

> 答：用户空间已知的唯一限制是 BPF_MAXINSNS (4096)。这是非特权 bpf 程序可以拥有的最大指令数。验证器有各种内部限制，如程序分析期间可以探索的最大指令数。目前，该限制设置为 100 万，这实质上意味着最大的程序可以包含 100 万条 NOP 指令。后续分支的最大数量有限制，嵌套 bpf-to-bpf 调用的数量有限制，每条指令的验证器状态数量有限制，程序使用的映射数量有限制。所有这些限制都可以通过足够复杂的程序来达到。还有可能导致程序被拒绝的非数量上的限制。以前验证器仅用于识别指针 + 常量表达式，现在它可以识别指针+ 有界寄存器。 以前bpf_lookup_map_elem(key) 函数要求“key”必须是指向堆栈的指针。现在，'key' 可以是指向映射值的指针。验证者正在稳步变得“更聪明”，限制正在被取消，程序被验证器通过的唯一方法是加载它。 bpf 开发过程保证未来的内核版本将接受所有被早期版本接受的 bpf 程序。


本文翻译自内核`Documentation/bpf/bpf_design_QA.rst`